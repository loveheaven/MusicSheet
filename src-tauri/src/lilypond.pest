// LilyPond Grammar for Pest Parser
// Complete lexical and syntactic analysis approach

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "%" ~ (!"\n" ~ ANY)* }

// Basic lexical tokens (based on lexer.ll)
letter = _{ 'a'..'z' | 'A'..'Z' | '\u{0080}'..'\u{FFFF}' }
digit = _{ '0'..'9' }

// Numbers and fractions
unsigned = @{ digit+ }
fraction = @{ digit+ ~ "/" ~ digit+ }
int = @{ "-"? ~ unsigned }
real = @{ (int ~ "." ~ digit*) | ("-"? ~ "." ~ digit+) }

// Identifiers and symbols
symbol = @{ letter ~ (("-" | "_")? ~ letter | letter)* }
identifier = @{ symbol }
command = @{ "\\" ~ symbol }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Special LilyPond literals
boolean_literal = @{ "##t" | "##f" }
// Direction and alignment constants
direction_constant = @{ "#" ~ ("UP" | "DOWN" | "LEFT" | "RIGHT" | "CENTER" | "up" | "down" | "left" | "right" | "center") }
// Number literals with # prefix (e.g., #0.2, #-1.9, #1)
scheme_number = @{ "#" ~ ("-"? ~ digit+ ~ ("." ~ digit+)? | "-"? ~ "." ~ digit+) }
// Scheme string literal with # prefix (e.g., #"8", #"text")
scheme_string = @{ "#" ~ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
markup_null = { "\\markup" ~ "\\null" }
// Scheme quoted expressions: #'identifier, #'(list), #'()
// Support nested parentheses in quoted lists
scheme_quote_paren = { "(" ~ scheme_quote_content ~ ")" }
scheme_quote_content = { (scheme_quote_paren | (!")" ~ ANY))* }
scheme_quote_list = { "#'" ~ scheme_quote_paren }
scheme_quote_symbol = @{ "#'" ~ identifier ~ (":" ~ identifier)* }
property_reference = { scheme_quote_symbol | scheme_quote_list }
unit_literal = @{ real ~ "\\" ~ identifier }

// Version directive
version = { "\\version" ~ string_literal }

// Language directive
language = { "\\language" ~ string_literal }

// Commands and directives
simple_command = { "\\" ~ identifier }
// Scheme code with support for nested parentheses and #{...#} blocks
scheme_lily_block = { "#{" ~ (!"#}" ~ ANY)* ~ "#}" }
scheme_paren = { "(" ~ scheme_content ~ ")" }
scheme_expr = { "#(" ~ scheme_content ~ ")" }
scheme_content = { (scheme_expr | scheme_lily_block | scheme_paren | (!")" ~ !"(" ~ ANY))* }
scheme_code = { scheme_expr }
include_directive = { "\\include" ~ string_literal }

// Custom event function call
// Format: \functionName arg1 arg2 ...
// Arguments can be: string_literal, scheme_number, markup_expression, property_reference, etc.
// Order matters: put more specific patterns first
function_argument = { string_literal | scheme_number | markup_expression | property_reference | scheme_code }
custom_function_call = { "\\" ~ identifier ~ WHITESPACE* ~ function_argument+ }

// Additional LilyPond commands
pointandclickoff = { "\\pointAndClickOff" }
numerictime = { "\\numericTimeSignature" }
break_command = { "\\break" }
bar_number_check = { "\\barNumberCheck" ~ "#" ~ unsigned }
arpeggio = { "\\arpeggio" }
bar_command = { "\\bar" ~ string_literal }

// Modal transpose and other transformations
// Format: \modalTranspose from_pitch to_pitch scale_ref music_expr
modal_transpose_pitch = @{ note_name ~ octave_modifier? }
modal_transpose = { "\\modalTranspose" ~ modal_transpose_pitch ~ modal_transpose_pitch ~ variable_reference ~ variable_reference }

// Comments in music (line number markers like "| % 1")
music_comment = { "|" ~ "%" ~ unsigned }

// Override and set commands
override_value = { scheme_code | scheme_expr | property_reference | direction_constant | scheme_string | scheme_number | string_literal | boolean_literal | int | real | identifier }
override_command = { "\\override" ~ identifier ~ ("." ~ identifier)+ ~ "=" ~ override_value }
// Set command supports both "context.property" and "property" formats
set_command = { "\\set" ~ identifier ~ ("." ~ identifier)? ~ "=" ~ override_value }

// Layout context commands
consists_command = { "\\consists" ~ (string_literal | ("#" ~ identifier) | identifier) }
remove_command = { "\\remove" ~ (string_literal | identifier) }
name_command = { "\\name" ~ identifier }
alias_command = { "\\alias" ~ identifier }
accepts_command = { "\\accepts" ~ identifier }

// Merge commands
merge_command = { "\\mergeDifferentlyDottedOn" | "\\mergeDifferentlyHeadedOn" }

// Helper for nested braces content
nested_braces = { "{" ~ (nested_braces | (!"}" ~ ANY))* ~ "}" }
braced_content = { (nested_braces | (!"}" ~ ANY))* }

// Paper block - handles nested braces
paper_block = { "\\paper" ~ "{" ~ braced_content ~ "}" }

// Markup expressions with nested braces
markup_expression = { "\\markup" ~ (nested_braces|string_literal) }
fromproperty = { "\\fromproperty" ~ property_reference }
fill_line = { "\\fill-line" ~ nested_braces }

// Variable definitions and references
variable_name = @{ (letter | digit | "_")+ }
variable_reference = { "\\" ~ variable_name }
// Bare music block (just braces without \relative, \fixed, etc.)
bare_music_block = { "{" ~ basic_music_sequence ~ "}" }
variable_value = { 
    override_command | set_command |
    music_mode | lyricmode | bare_music_block | 
    custom_function_call | variable_reference | 
    scheme_code | string_literal | real | unsigned 
}
variable_definition = { variable_name ~ "=" ~ variable_value }

// Header block with proper parsing
// Header values can be: string_literal, boolean_literal, markup_expression, scheme_code, etc.
header_value = { markup_expression | string_literal | boolean_literal | scheme_code | identifier }
header_item = { identifier ~ "=" ~ header_value }
header = { "\\header" ~ "{" ~ header_item* ~ "}" }

// Musical elements - detailed parsing

// Key signature
// Support both English and German note naming
key_note = @{ ("h" | "c" | "d" | "e" | "f" | "g" | "a" | "b") ~ ("is" | "es")? }
key_mode = @{ "\\major" | "\\minor" }
key_signature = { "\\key" ~ key_note ~ key_mode }

// Partial (pickup measure)
partial = { "\\partial" ~ duration }

// Time signature
time_signature = { "\\time" ~ (fraction | (unsigned ~ "/" ~ unsigned)) }

// Clef
clef_type = @{ "treble" | "bass" | "alto" | "tenor" | "percussion" | "tab" }
clef = { "\\clef" ~ (string_literal | clef_type | identifier) }

// Ottava (octave transposition)
// Format: \ottava #n where n is the octave offset (0, 1, -1, 2, -2, etc.)
ottava = { "\\ottava" ~ "#" ~ int }


// Articulations and dynamics
articulation = @{ ">" | "^" | "_" | "." | "-" | "+" | "!" }
articulation_command = @{ "\\accent" | "\\espressivo" | "\\staccato" | "\\staccatissimo" | "\\portato" | "\\tenuto" | "\\marcato"}
ornament = @{ "\\prall" | "\\prallup" | "\\pralldown"   | "\\upprall" | "\\downprall" | "\\prallprall" | "\\lineprall" | "\\prallmordent" | "\\mordent" | "\\upmordent" | "\\downmordent" | "\\trill" | "\\turn" | "\\reverseturn" | "\\slashturn" | "\\haydnturn" }
fermata = @{ "\\veryshortfermata" | "\\shortfermata" | "\\fermata" | "\\longfermata" | "\\verylongfermata" | "\\henzeshortfermata" | "\\henzelongfermata" }
repeatsign = @{ "\\segno" | "\\coda" | "\\varcoda" }
instrumentsign = @{ "\\upbow" | "\\downbow" | "\\flageolet" | "\\open" | "\\halfopen" | "\\lheel" | "\\rheel" | "\\ltoe" | "\\rtoe" | "\\snappizzicato" | "\\stopped" | "\\thumb" }
accientsign = @{ "\\accentus" | "\\circulus"  | "\\ictus" | "\\semicirculus" | "\\signumcongruentiae"}
dynamic = @{ "\\pp" | "\\p" | "\\mp" | "\\mf" | "\\f" | "\\ff" | "\\fff" | "\\ffff" | "\\fffff" | "\\fp" | "\\sf" | "\\sff" | "\\sp" | "\\spp" | "\\sfz" | "\\rfz" | "\\ppp" | "\\pppp" | "\\ppppp"}
mark_attach_sign = { articulation_command | ornament | fermata | repeatsign | instrumentsign | accientsign | dynamic } 

// Note components with precise parsing
// Support both English and German note naming (h for B-natural in German)
note_name = @{ ("h" | "c" | "d" | "e" | "f" | "g" | "a" | "b" ) ~ ("is" | "es" | "s" | "isis" | "eses")? }
octave_modifier = @{ ("'" | ",")* }
duration_number = @{ "128" | "64" | "32" | "16" | "8" | "4" | "2" | "1" }
duration_dots = @{ "."* }
duration = { duration_number ~ duration_dots }

// Musical note with optional slur marker, fingering, repeat tie, and script/text attachments
slur_marker = { "~" }
// Slur markers - can be standalone (not necessarily paired in same block)
slur_start = { "(" }
slur_end = { ")" }

// Multiplier for repetition (e.g., * 18 to repeat 18 times)
multiplier = { "*" ~ unsigned }

// Script attachment: ^, _, or - followed by optional text/markup
script_direction = { "^" | "_" | "-" }
script_text = { string_literal | markup_expression | articulation | unsigned }
script_attachment = { script_direction ~ script_text? }

// Accidental modifiers (must come after octave_modifier, before duration)
// ! = forced reminder accidental
// ? = cautionary accidental (in parentheses)
accidental_modifier = @{ "!" | "?" }

// Fingering can appear before or after duration
musical_note = { note_name ~ octave_modifier ~ accidental_modifier? ~ duration? ~ script_attachment* ~ mark_attach_sign? ~ (slur_marker | repeat_tie)? ~ multiplier? }

// Angle brackets for chords - supports duration, fingering, and script attachments like regular notes
// Format: <notes with fingerings> [fingering] [duration] [fingering] [script_attachment]* [multiplier]?
angle_brackets = { "<" ~ musical_note+ ~ ">"  ~ duration? ~ script_attachment* ~ mark_attach_sign? ~ multiplier? }

// Rest
rest_name = @{ "r" | "s" }
// Rest with optional dynamic markings
rest = { rest_name ~ duration? ~ (crescendo_start | decrescendo_start | dynamic_stop)? ~ multiplier? }


// Multi-measure rest (R with duration)
multi_measure_rest = { "R" ~ duration? ~ multiplier? }

// Chord repetition - 'q' repeats the previous chord
chord_repetition = { "q" ~ duration?  ~ script_attachment* ~ mark_attach_sign? ~ multiplier? }

// Bar lines
bar_line = { "|" }
double_bar = { "||" }
final_bar = { "|." }

// Tempo markings
tempo = { "\\tempo" ~ (string_literal | (duration ~ "=" ~ unsigned)) }

// Hairpin dynamics (crescendo/decrescendo)
crescendo_start = { "\\" ~ "<" }
decrescendo_start = { "\\" ~ ">" }
dynamic_stop = { "\\" ~ "!" }

// Alternative block for repeats
alternative_block = { "\\alternative" ~ "{" ~ alternative_choice* ~ "}" }
alternative_choice = { "{" ~ basic_music_sequence ~ "}" }

// Repeat commands
repeat_type = @{ "volta" | "segno" | "unfold" | "percent" | "tremolo" }
repeat_times = @{ digit+ }
repeat_volta = { "\\repeat" ~ repeat_type ~ repeat_times ~ "{" ~ basic_music_sequence ~ "}" ~ alternative_block? }



// Grace notes (ornaments)
grace_notes = { "\\grace" ~ "{" ~ basic_music_sequence ~ "}" }
acciaccatura_notes = { "\\acciaccatura" ~ "{" ~ basic_music_sequence ~ "}" }
appoggiatura_notes = { "\\appoggiatura" ~ "{" ~ basic_music_sequence ~ "}" }

// Repeat tie
repeat_tie = { "\\repeatTie" }

// Tuplet commands
// \tuplet fraction { music }
tuplet_fraction = { unsigned ~ "/" ~ unsigned }
tuplet = { "\\tuplet" ~ tuplet_fraction ~ "{" ~ basic_music_sequence ~ "}" }

// \tupletSpan duration
tuplet_span = { "\\tupletSpan" ~ (duration | unsigned) }

// Omit command (e.g., \omit TupletNumber)
omit_command = { "\\omit" ~ identifier }

// Basic music items (no modes to avoid circular reference)
// IMPORTANT: Order matters in PEG parsing!
// Put more specific patterns (like commands starting with \) before generic patterns (like musical_note)
basic_music_item = { 
    modal_transpose |
    repeat_volta | grace_notes | acciaccatura_notes | appoggiatura_notes |
    tuplet | tuplet_span | omit_command |
    key_signature | time_signature | clef | tempo | ottava | partial |
    break_command | bar_number_check | 
    arpeggio | bar_command |
    override_command | set_command | merge_command |
    pointandclickoff | numerictime |
    custom_function_call |
    variable_reference |
    musical_note | rest | multi_measure_rest | chord_repetition |
    bar_line | double_bar | final_bar |
    slur_start | slur_end | angle_brackets |
    crescendo_start | decrescendo_start | dynamic_stop |
    music_comment
}

// Basic music sequence
basic_music_sequence = { basic_music_item* }

// Lyrics - support Unicode characters for international text
// Lyric text - plain text excluding commands and closing brace
lyric_text = @{ (!"}" ~ !("\\" ~ letter) ~ ANY)+ }

// Basic lyric item - text, set command, or override command (no variable reference)
basic_lyric_item = { 
    override_command | 
    set_command | 
    lyric_text 
}

// Basic lyric sequence - sequence of basic lyric items (no variable reference)
basic_lyric_sequence = { basic_lyric_item+ }

// Lyric item - adds variable reference to basic lyric item
lyric_item = { 
    variable_reference | 
    basic_lyric_item
}

// Lyric sequence - sequence of lyric items (includes variable reference)
lyric_sequence = { lyric_item*}

// Music modes and transformations
fixed_reference = { note_name ~ octave_modifier }
relative_reference = { note_name ~ octave_modifier }

fixed_mode = { "\\fixed" ~ fixed_reference ~ "{" ~ basic_music_sequence ~ "}" }
relative_mode = { "\\relative" ~ relative_reference? ~ "{" ~ basic_music_sequence ~ "}" }
absolute_mode = { "\\absolute" ~ "{" ~ basic_music_sequence ~ "}" }
lyricmode = { "\\lyricmode" ~ "{" ~ basic_lyric_sequence ~ "}" }

// Enhanced music expression to include modes
music_mode = { fixed_mode | relative_mode | absolute_mode }

// Full music item including modes
music_item = { new_voice  | new_lyrics | new_dynamics | new_nullvoice | basic_music_item | music_mode  }

// Music sequence - properly parsed sequence of music items
music_sequence = { music_item* }

// New staff/voice commands - support both Staff and Voice
context_type = @{ "Staff" | "Voice" | "PianoStaff" | "ChoirStaff" | "GrandStaff" | "StaffGroup" | "Dynamics" | "NullVoice" }
new_context = { "\\new" ~ context_type ~ ("=" ~ (identifier | string_literal))? }
new_voice = { "\\new" ~ "Voice" ~ ("=" ~ (identifier | string_literal))? ~ (simple_staff | music_mode | variable_reference) }
new_lyrics = { "\\new" ~ "Lyrics" ~ ("=" ~ (identifier | string_literal))? ~ ((lyricsto ~ ("{" ~ lyric_sequence ~ "}" | variable_reference)) | lyricmode)? }
new_dynamics = { "\\new" ~ "Dynamics" ~ ("=" ~ (identifier | string_literal))? ~ (simple_staff | music_mode | variable_reference | bare_music_block) }
new_nullvoice = { "\\new" ~ "NullVoice" ~ ("=" ~ (identifier | string_literal))? ~ (simple_staff | music_mode | variable_reference | bare_music_block) }
lyricsto = { "\\lyricsto" ~ string_literal }
addlyrics = { "\\addlyrics" ~ "{" ~ lyric_sequence ~ "}" }

// Staff directives
staff_directive = { clef | key_signature | time_signature | tempo  }

// Staff and Voice content - structured parsing instead of raw capture
staff_body = { staff_directive* ~ music_sequence }
staff = { "\\new" ~ "Staff" ~ ("=" ~ (identifier | string_literal))? ~ "{" ~ staff_body ~ "}" }
simple_staff = { "{" ~ staff_body ~ "}" }

// Score structure
// Layout and MIDI blocks - ignore all content with nested braces support
layout_content = { (nested_braces | (!"}" ~ ANY))* }
layout_block = { "\\layout" ~ "{" ~ layout_content ~ "}" }
midi_block = { "\\midi" ~ "{" ~ layout_content ~ "}" }

// Simultaneous music (parallel staves)
simultaneous_music = { "<<" ~ (staff | simple_staff | music_mode | new_voice | new_lyrics | new_dynamics | new_nullvoice)* ~ ">>" }

// Piano staff - contains simultaneous music
piano_staff = { "\\new" ~ "PianoStaff" ~ ("=" ~ (identifier | string_literal))? ~ simultaneous_music }

// Score content with more options
score_content = { 
    piano_staff | staff | simple_staff | music_mode  | new_lyrics | new_dynamics | new_nullvoice | addlyrics | simultaneous_music
}
score = { "\\score" ~ "{" ~ score_content ~ layout_block? ~ midi_block? ~ "}" }

// Book structures
book_item = { score | header }
book = { "\\book" ~ "{" ~ book_item* ~ "}" }
bookpart = { "\\bookpart" ~ "{" ~ book_item* ~ "}" }

// Top level structure
top_level_item = { 
    paper_block | version | language | header | score | book | bookpart | music_mode | 
    include_directive | variable_definition | scheme_code | layout_block |
    pointandclickoff | simple_command
}
lilypond_file = { SOI ~ top_level_item* ~ EOI }
